<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta title="UE INF304 - TP8">
<style>
emph {
  font-weight: bold;
}

#content {
  margin: 0% auto;
  width: 80ex;
  max-width: 80%;
  align: center;
}

p, ul, ol, li {
  text-align: justify;
}

h1,h2 {
text-align: center;
}

h5:before {
  content: "\25B6\00A0" ;
}

.important {
   color: #FF0000;
}

.nom { font-family: sans-serif; font-weight:bold; }

.code { font-family: monospace; }

.file { font-family: monospace; }

.commande { font-family: monospace; }

.algo { 
font-family: sans-serif; 
border: solid 1px #DDD;
background-color: #F9F9F9;
padding: 1ex;
margin:5%;
}

pre.code {
border: solid 1px #DDD;
background-color: #F9F9F9;
padding: 1ex;
margin:5%;
}

.text { font-style: oblique; }
.comment { font-style: oblique; }

.kw { font-weight: bold; color: #007700;}

.block {
  border-left: solid 2px #009900; 
  padding: 0px;
  margin: 0px;
  padding-left: 1ex;
  padding-bottom: 4px;
  margin-left: 4ex;
}

table { border: solid 1px; border-collapse: collapse; margin: auto; }
th,td { border: solid 1px; padding: 5px; }
td.notation { border-left: none; border-right: none;}

</style>

</head><body>


<div id="content">

  <h1>INF304 — TP8</h1>

  <h2>Curiosity Revolutions (3)<br>
    Génération aléatoire de terrains</h2>

  <p>Ce TP est la suite des TP précédents ; placez-vous dans le
  répertoire de ces TP précédents, et copiez-y les fichiers
  nécessaires au TP8 :
</p><pre class="code">cp -r /Public/304_INF_Public/TP8/* .
</pre>
<p></p>

<p>Au cours de ce TP, vous serez amenés à compléter des programmes
fournis. Il est important de vous les approprier (relire les en-têtes
de chacun afin de voir ce qu'ils contiennent par exemple).</p>

<p>De même, vous devrez compléter le
  fichier <span class="file">Makefile</span> des TPs précédents, pour
  permettre la création des différents exécutables de ce TP.</p>

<h3>Génération de terrains</h3>

<h5>Exercice 1.</h5>

  <p>Compléter la
  fonction <span class="code">generation_aleatoire</span> du
  paquetage <span class="file">generation_terrains</span>. Compléter
  le programme <span class="file">test_generation_terrains.c</span>
  afin de pouvoir générer un fichier de terrains contenant <i>n</i>
  terrains de dimensions <i>L × H</i> avec une densité
  d'obstacles <i>dObst</i> (densité entre 0 et 1) pour les cases
  occupées, chaque terrain généré devant être valide, c'est-à-dire
  possèder un chemin de cases libres du centre au bord (utiliser la
  fonction <span class="code">existe_chemin_vers_sortie</span>
  fournie). On positionnera le robot au centre du terrain.</p>

<p>Pour la génération aléatoire d'un terrain, vous utiliserez un des
  algorithmes vus en cours.</p>


<h5>Exercice 2.</h5>

  <p>Écrire dans le fichier, en plus de chaque terrain, la densité
  d'obstacle obtenue (à comparer avec la densité donnée attendue) et à
  la fin du fichier la densité d'obstacle moyenne sur les terrains
  ainsi que le pourcentage de terrain valides par rapport au nombre
  total généré.</p>

<h3>Test de performance</h3>

<h5>Exercice 3.</h5>
<p>Écrire un programme <span class="file">curiosity-perf</span> sur la
  base du programme précédent et en prenant exemple
  sur <span class="file">curiosity</span> afin de tester la
  «performance» du programme utilisé.</p>

<p>Le programme <span class="file">curiosity-perf</span> devra prendre
  comme arguments :
</p><pre class="code">curiosity-perf fichier_programme N L H d graine nb_step_max fichier_res
</pre>
où :
<ul>
  <li><span class="code">fichier_programme</span> est le fichier
  contenant le programme-robot évalué</li>
  <li><span class="code">N</span> est le nombre de terrains utilisés
  pour l'évaluation</li>
  <li><span class="code">L</span>, impair, la largeur des terrains</li>
  <li><span class="code">H</span>, impair, la hauteur des terrains</li>
  <li><span class="code">d</span>, la densité d'obstacles</li>
  <li><span class="code">graine</span>, la graine du générateur aléatoire</li>
  <li><span class="code">nb_step_max</span>, le nombre de pas maximum
  pour chaque exécution du programme sur un terrain</li>
  <li><span class="code">fichier_res</span>, le nom du fichier dans
  lequel seront écrits les résultats.</li>
</ul>
<p></p>
<p>Dans ce cas :
</p><ul>
<li>Le fichier <span class="code">fichier_programme</span> doit contenir un
  programme «infini».
</li><li>Le fichier <span class="code">fichier_res</span> sera écrit avec les
statistiques de résultat, avec le format suivant :
<ul>
<li><b>[ligne 1]</b> : <span class="code">n</span> (nombre de terrains testés)
</li></ul>
suivie de <span class="code">n</span> lignes, une valeur par ligne
<ul>
<li><b>[ligne <span class="code">i+1</span>]</b> (pour le terrain
numéro <span class="code">i</span>) :
<ul>
  <li>si curiosity est sorti, le nombre de pas effectués
  </li><li>sinon, curiosity est «bloqué» (<span class="code">-1</span>),  «tombé dans l'eau» (<span class="code">-2</span>), «écrasé contre un rocher» (<span class="code">-3</span>)
</li></ul>
</li></ul>
</li><li>enfin, le programme affiche (sur la sortie standard) des
  statistiques pertinentes de «performance» du programme : nombre et
  pourcentage de terrains d'où le robot est sorti/où il est resté
  bloqué/où il est rentré dans un obstacle ; nombre moyen de pas
  effectués pour les sorties.
</li></ul>


<h3>Élaboration d'un programme plus complexe</h3>
<p>Il est possible de créer des programmes infinis comme (voir annexe
  TD6 et 7) :
</p><ul>
<li>Fait avancer indéfiniment le robot : «<b>{ A C ! } C !</b>»
</li><li>Mesure la case devant lui et avance si la case est libre, tourne à
  gauche s'il y a un obstacle : «<b>{ 1 M { G } { A } ? C ! } C !</b>»
</li></ul>
Soit le schéma général : «<b>{ cmds C ! } C !</b>», exécutant
indéfiniment la séquence de commandes «<b>cmds</b>».
<p></p>

<h5>Exercice 4.</h5>
<p>En partant de ce principe, élaborer PLUSIEURS programmes permettant au
  robot de tenter de sortir de n'importe quel terrain.</p>

<p><b>NB :</b> il faut que vous soyiez capable d'<em>expliquer</em> le
  comportement de ces programmes&nbsp;!</p>


<h5>Exercice 5.</h5>
  <p>Tester ces programmes sur différents terrains.</p>

<p><b>NB :</b> sur de grands terrains ou un nombre de pas maximum
  important, il peut être nécessaire d'augmenter la taille de la pile.</p>
  
  <p>Pour chacun de ces programmes, écrire :
  </p><ul>
  <li>un terrain sur lequel le programme permet au robot de sortir ;
  </li><li>un terrain sur lequel le robot reste bloqué (rentre dans un
    obstacle, ou boucle indéfiniment sans sortir du terrain).
  </li></ul>
  <p></p>
  <p>
  Savez-vous <em>caractériser</em> les terrains sur lesquels le
  programme permet/ne permet pas au robot de sortir ?
  </p>

<h5>Exercice 6.</h5>
  <p>Tester au moins deux de vos programmes sur des terrains de
    diverses densités d'obstacles. Comparer les résultats statistiques
    de sortie, pour différentes valeurs de paramètres.</p>


<h3>Compte Rendu</h3>
<p>Déposer sur la page moodle du cours :
</p><ul>
<li>Un document PDF avec la description de deux programmes plus
performants que celui de base («Avancer indéfiniment»),
</li><li>Pour chacun des deux programme, les fichiers
résultats du programme <span class="file">curiosity_perf</span> pour les terrains générés :
<ul>
  <li><i>n=20</i>, <i>L = H = 25</i>, occupation totale de <i>40 %</i></li>
  <li><i>n=20</i>, <i>L = H = 9</i>, occupation totale de <i>70 %</i></li>
</ul></li>
<ul>
<li>Donner pour vos deux programmes les paramétrages de terrain où chacun des programmes :
<ul>
<li>sort «presque» toujours
</li><li>ne sort «presque» jamais
</li></ul></li>
</ul>
</ul>

</div>

</body></html>